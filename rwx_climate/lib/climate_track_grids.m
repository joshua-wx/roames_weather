function track_grids = climate_track_grids(track_grids,track_ind,storm_date_list,storm_latloncent_list,...
    storm_subset_list,storm_ijbox_list,db_root,radar_id,r_scale,stormh5_varname,data_min,radar_step)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Joshua Soderholm, Fugro ROAMES, 2017
%
% WHAT: For a list of database index values that form a track, generate a
% density and motion field for that track and add these to the track_grids
% struct.
% This process requires extraction of data from the storm.h5 files.
%
% INPUTS
% track_grids:          struct continaing accumulated density and motion
%                       fields (density_grid: track counts, u_grid: u motion field, v_grid: v motion field,
%                       n_grid: total overlap count for motion normalisation)
% track_ind:            index of track entires from database (mx1)
% storm_date_list:      date list (nx1)
% storm_latloncent_list:lat,lon centroid list (nx2)
% storm_subset_list:    subset id list (nx1) only unique for each scan
% storm_ijbox_list:     ij coord list (nx4) for storm.h5 fields, in [max i,
%                       min i, max j, min j]
% db_root:              root for archive path (string)
% radar_id:             radar id (double)
% r_scale:              storm h5 data scaling (double)
% stormh5_varname:      target variable name in storm h5 (string)
% data_min:             min value for storm h5 data filtering (double)
% radar_step:           radar step for current date (double)
%
% RETURNS track_grids: see above
%
% NOTES: swath polygons are generated by performing the convex hull around
% pairs of cells in a track and applying the union to these processed
% pairs. Pairs are composed of inital and final cells.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%preallocate cell array to store extracted storm.h5 fields
storm_data = cell(length(track_ind),1);

%correct data_min if nan
if strcmp(data_min,'nan')
    data_min = 0;
end

%load storm h5 datafield from file for each track index
for i = 1:length(track_ind)
    %build paths to h5 from date and radar_id
    target_date    = storm_date_list(track_ind(i));
    target_subset  = storm_subset_list(track_ind(i));
    target_datevec = datevec(target_date);
    target_fn      = [num2str(radar_id,'%02.0f'),'_',datestr(target_date,'yyyymmdd_HHMMSS'),'.storm.h5'];
    target_ffn     = [db_root,num2str(radar_id,'%02.0f'),'/',num2str(target_datevec(1)),'/',...
        num2str(target_datevec(2),'%02.0f'),'/',num2str(target_datevec(3),'%02.0f'),'/',target_fn];
    %read required h5 field
    h5data         = h5read(target_ffn,['/',num2str(target_subset),'/',stormh5_varname]);
    %rescale data
    h5data         = double(h5data)./r_scale;
    %store in cell array
    storm_data{i}  = h5data;
end

%density track
blank_grid         = zeros(size(track_grids.density_grid));
total_density_grid = blank_grid;
max_grid           = blank_grid;
track_u_grid       = blank_grid;
track_v_grid       = blank_grid;

%assign initial pair data
init_ind        = track_ind(1:end-1);
init_storm_data = storm_data(1:end-1);
init_latloncent = storm_latloncent_list(init_ind,:);
init_ijbox      = storm_ijbox_list(init_ind,:);
init_date_list  = storm_date_list(init_ind);
%assign final pair data
finl_ind        = track_ind(2:end);
finl_storm_data = storm_data(2:end);
finl_latloncent = storm_latloncent_list(finl_ind,:);
finl_ijbox      = storm_ijbox_list(finl_ind,:);
finl_date_list  = storm_date_list(finl_ind);

%loop through pairs
for i=1:length(init_ind)
    %skip if track segment not continous in time (mask removes cells from tracks which don't meet
    %criteria, these pairs need to be skipped)
    if floor((finl_date_list(i)-init_date_list(i))*24*60) > radar_step
        continue
    end
    %create conv of inital and final
    %create inital mask
    init_grid  = blank_grid;
    init_grid(init_ijbox(i,1):init_ijbox(i,2),init_ijbox(i,3):init_ijbox(i,4)) = init_storm_data{i};
    init_mask  = init_grid > data_min;
    %create final mask
    finl_grid  = blank_grid;
    finl_grid(finl_ijbox(i,1):finl_ijbox(i,2),finl_ijbox(i,3):finl_ijbox(i,4)) = finl_storm_data{i};
    finl_mask  = finl_grid > data_min;
    %apply convex hull
    conv_mask  = bwconvhull(init_mask + finl_mask);
    %build max grid
    if i==1
        max_grid = max(cat(3,max_grid,init_grid),[],3);
    end
    max_grid = max(cat(3,max_grid,finl_grid),[],3);
    %calc u,v for pair
    %use distance function
    [dist,az]       = distance(init_latloncent(i,1),init_latloncent(i,2),finl_latloncent(i,1),finl_latloncent(i,2));
    dist            = deg2km(dist); %convert deg to km
    vel             = dist/((finl_date_list(i)-init_date_list(i))*24); %convert km to km/h
    az              = mod(90-az,360); %convert from compass to cartesian deg
    az_u            = vel*cosd(az); %use velocity and azimuth to calc u,v
    az_v            = vel*sind(az); %use velocity and azimuth to calc v
    u_mask          = conv_mask.*az_u; %apply velocity values to masked areas
    v_mask          = conv_mask.*az_v;
    %append masks to track grids
    total_density_grid = total_density_grid + conv_mask;
    track_u_grid       = track_u_grid + u_mask;
    track_v_grid       = track_v_grid + v_mask;
end
%normalise density
norm_density_grid        = total_density_grid>0;
%accumulate
track_grids.density_grid = track_grids.density_grid + norm_density_grid;
track_grids.u_grid       = track_grids.u_grid       + track_u_grid;
track_grids.v_grid       = track_grids.v_grid       + track_v_grid;
track_grids.n_grid       = track_grids.n_grid       + total_density_grid;
%append
track_grids.max_grid     = max(cat(3,track_grids.max_grid,max_grid),[],3);
