function out_struct = process_swath(track_latloncent,track_ijbox,track_date_list,track_data,data_mask,radar_step,grid_size)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Joshua Soderholm, Fugro ROAMES, 2017
%
% WHAT:
%
% INPUTS
%
% RETURNS
%
% NOTES: swath polygons are generated by performing the convex hull around
% pairs of cells in a track and applying the union to these processed
% pairs. Pairs are composed of inital and final cells.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%need to define blank grid
blank_grid   = zeros(grid_size(1),grid_size(2));
max_grid     = blank_grid;
density_grid = blank_grid;
u_grid       = blank_grid;
v_grid       = blank_grid;

%calc inital and final index
if length(track_date_list)>1
    init_idx = [1:length(track_date_list)-1];
    finl_idx = [2:length(track_date_list)];
else %case of single cell, duplicate init and final
    init_idx = 1;
    finl_idx = 1;
end

%assign initial pair data
init_storm_data = track_data(init_idx);
init_latloncent = track_latloncent(init_idx,:);
init_ijbox      = track_ijbox(init_idx,:);
init_date_list  = track_date_list(init_idx);
%assign final pair data
finl_storm_data = track_data(finl_idx);
finl_latloncent = track_latloncent(finl_idx,:);
finl_ijbox      = track_ijbox(finl_idx,:);
finl_date_list  = track_date_list(finl_idx);

%loop through pairs
for i=1:length(init_idx)
    %skip if track segment not continous in time (mask removes cells from tracks which don't meet
    %criteria, these pairs need to be skipped)
    if floor((finl_date_list(i)-init_date_list(i))*24*60) > radar_step*2
        continue
    end
    %create conv of inital and final
    %create inital mask
    init_grid  = blank_grid;
    init_grid(init_ijbox(i,1):init_ijbox(i,2),init_ijbox(i,3):init_ijbox(i,4)) = init_storm_data{i};
    init_mask  = init_grid > data_mask;
    %create final mask
    finl_grid  = blank_grid;
    finl_grid(finl_ijbox(i,1):finl_ijbox(i,2),finl_ijbox(i,3):finl_ijbox(i,4)) = finl_storm_data{i};
    finl_mask  = finl_grid > data_mask;
    %apply convex hull
    conv_grid  = bwconvhull(init_mask + finl_mask);
    %build max grid
    if i==1
        max_grid = max(cat(3,max_grid,init_grid),[],3);
    end
    max_grid = max(cat(3,max_grid,finl_grid),[],3);
    %calc u,v for pair
    %use distance function
    [dist,az]       = distance(init_latloncent(i,1),init_latloncent(i,2),finl_latloncent(i,1),finl_latloncent(i,2));
    dist            = deg2km(dist); %convert deg to km
    vel             = dist/((finl_date_list(i)-init_date_list(i))*24); %convert km to km/h
    az              = mod(90-az,360); %convert from compass to cartesian deg
    az_u            = vel*cosd(az); %use velocity and azimuth to calc u,v
    az_v            = vel*sind(az); %use velocity and azimuth to calc v
    u_temp          = conv_grid.*az_u; %apply velocity values to masked areas
    v_temp          = conv_grid.*az_v;
    %append masks to track grids
    density_grid = density_grid + conv_grid;
    u_grid       = u_grid + u_temp;
    v_grid       = v_grid + v_temp;
end
%output
out_struct   = struct('density_grid',density_grid,'max_grid',max_grid,'u_grid',u_grid,'v_grid',v_grid);
